var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
(function (factory) {
    if (typeof module === "object" && typeof module.exports === "object") {
        var v = factory(require, exports);
        if (v !== undefined) module.exports = v;
    }
    else if (typeof define === "function" && define.amd) {
        define(["require", "exports", "./types", "./utils", "./types", "./utils"], factory);
    }
})(function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.TwoDimensionScroll = void 0;
    const types_1 = require("./types");
    const utils_1 = require("./utils");
    /**
     * 2Ï∞®Ïõê Ïä§ÌÅ¨Î°§ ÎùºÏù¥Î∏åÎü¨Î¶¨
     * Í∞ÄÎ°úÏôÄ ÏÑ∏Î°ú Ïä§ÌÅ¨Î°§ÏùÑ Î™®Îëê Í∞êÏßÄÌïòÏó¨ Î∂ÄÎìúÎü¨Ïö¥ ÏÑ∏Î°ú Ïä§ÌÅ¨Î°§Î°ú Î≥ÄÌôò
     */
    class TwoDimensionScroll {
        constructor(options = {}) {
            this.isAnimating = false;
            this.animationFrame = null;
            this.rafId = null;
            this.lastScrollTop = 0;
            this.touchStartY = 0;
            this.touchStartX = 0;
            this.touchStartTime = 0;
            this.isScrolling = false;
            this.scrollCallbacks = new Set();
            this.isMobileDevice = false;
            this.passive = false;
            /**
             * Ìú† Ïù¥Î≤§Ìä∏ Ìï∏Îì§Îü¨
             */
            this.onWheel = (event) => {
                if (this.options.disabled || this.isScrolling)
                    return;
                event.preventDefault();
                const deltaX = event.deltaX * this.options.horizontalSensitivity;
                const deltaY = event.deltaY * this.options.verticalSensitivity;
                // ÎîîÎ≤ÑÍ∑∏ Î™®ÎìúÏóêÏÑú ÏõêÏãú Ïù¥Î≤§Ìä∏ Îç∞Ïù¥ÌÑ∞ Ï∂úÎ†•
                if (this.options.debug) {
                    console.log("üñ±Ô∏è Ìú† Ïù¥Î≤§Ìä∏:", {
                        ÏõêÏãú_deltaX: event.deltaX,
                        ÏõêÏãú_deltaY: event.deltaY,
                        Ï°∞Ï†ïÎêú_deltaX: deltaX,
                        Ï°∞Ï†ïÎêú_deltaY: deltaY,
                        deltaMode: event.deltaMode,
                        Í∞ÄÎ°úÏä§ÌÅ¨Î°§_Í∞êÏßÄ: Math.abs(deltaX) > Math.abs(deltaY) ? "‚úÖ YES" : "‚ùå NO",
                    });
                }
                // Í∞ÄÎ°úÏôÄ ÏÑ∏Î°ú Ïä§ÌÅ¨Î°§ Ï°∞Ìï© Ï≤òÎ¶¨
                const combinedDelta = this.calculateCombinedDelta(deltaX, deltaY);
                this.handleScroll(combinedDelta, "wheel");
            };
            /**
             * ÌÑ∞Ïπò ÏãúÏûë Ïù¥Î≤§Ìä∏ Ìï∏Îì§Îü¨
             */
            this.onTouchStart = (event) => {
                if (this.options.disabled)
                    return;
                const touch = event.touches[0];
                this.touchStartX = touch.clientX;
                this.touchStartY = touch.clientY;
                this.touchStartTime = Date.now();
            };
            /**
             * ÌÑ∞Ïπò Ïù¥Îèô Ïù¥Î≤§Ìä∏ Ìï∏Îì§Îü¨
             */
            this.onTouchMove = (event) => {
                if (this.options.disabled || this.isScrolling)
                    return;
                const touch = event.touches[0];
                const deltaX = (this.touchStartX - touch.clientX) * this.options.horizontalSensitivity;
                const deltaY = (this.touchStartY - touch.clientY) * this.options.verticalSensitivity;
                // ÏùòÎØ∏ÏûàÎäî Ïù¥ÎèôÏù¥ ÏûàÏùÑ ÎïåÎßå Ï≤òÎ¶¨
                if (Math.abs(deltaX) > 10 || Math.abs(deltaY) > 10) {
                    event.preventDefault();
                    const combinedDelta = this.calculateCombinedDelta(deltaX, deltaY);
                    this.handleScroll(combinedDelta, "touch");
                }
            };
            /**
             * ÌÑ∞Ïπò Ï¢ÖÎ£å Ïù¥Î≤§Ìä∏ Ìï∏Îì§Îü¨
             */
            this.onTouchEnd = (event) => {
                if (this.options.disabled)
                    return;
                // ÌîåÎßÅ Ï†úÏä§Ï≤ò Ï≤òÎ¶¨ (Îπ†Î•∏ Ïä§ÏôÄÏù¥ÌîÑ)
                const touch = event.changedTouches[0];
                const deltaTime = Date.now() - this.touchStartTime;
                const deltaY = this.touchStartY - touch.clientY;
                if (deltaTime < 300 && Math.abs(deltaY) > 50) {
                    const velocity = deltaY / deltaTime;
                    const flingDistance = velocity * 200; // ÌîåÎßÅ Í±∞Î¶¨ Í≥ÑÏÇ∞
                    this.handleScroll(flingDistance, "touch");
                }
            };
            /**
             * ÌÇ§Î≥¥Îìú Ïù¥Î≤§Ìä∏ Ìï∏Îì§Îü¨
             */
            this.onKeyDown = (event) => {
                if (this.options.disabled || this.isScrolling)
                    return;
                let delta = 0;
                const scrollAmount = window.innerHeight * 0.8; // ÌôîÎ©¥ ÎÜíÏù¥Ïùò 80%
                switch (event.key) {
                    case "ArrowUp":
                    case "PageUp":
                        delta = -scrollAmount;
                        break;
                    case "ArrowDown":
                    case "PageDown":
                    case " ": // Ïä§ÌéòÏù¥Ïä§Î∞î
                        delta = scrollAmount;
                        break;
                    case "Home":
                        delta = -(0, utils_1.getCurrentScrollTop)();
                        break;
                    case "End":
                        delta = (0, utils_1.getMaxScrollTop)() - (0, utils_1.getCurrentScrollTop)();
                        break;
                    default:
                        return;
                }
                event.preventDefault();
                this.handleScroll(delta, "keyboard");
            };
            /**
             * Î¶¨ÏÇ¨Ïù¥Ï¶à Ïù¥Î≤§Ìä∏ Ìï∏Îì§Îü¨
             */
            this.onResize = () => {
                // ÌòÑÏû¨ Ïä§ÌÅ¨Î°§ ÏúÑÏπòÍ∞Ä ÏµúÎåÄÍ∞íÏùÑ Ï¥àÍ≥ºÌïòÏßÄ ÏïäÎèÑÎ°ù Ï°∞Ï†ï
                const maxScrollTop = (0, utils_1.getMaxScrollTop)();
                const currentScrollTop = (0, utils_1.getCurrentScrollTop)();
                if (currentScrollTop > maxScrollTop) {
                    this.scrollTo(maxScrollTop);
                }
            };
            /**
             * Ïï†ÎãàÎ©îÏù¥ÏÖò Ïã§Ìñâ
             */
            this.animate = () => {
                if (!this.animationFrame)
                    return;
                const now = performance.now();
                const elapsed = now - this.animationFrame.startTime;
                const progress = Math.min(elapsed / this.animationFrame.duration, 1);
                const easedProgress = this.animationFrame.easing(progress);
                const currentPosition = this.animationFrame.startPosition +
                    (this.animationFrame.targetPosition - this.animationFrame.startPosition) *
                        easedProgress;
                window.scrollTo(0, currentPosition);
                if (progress < 1) {
                    this.rafId = (0, utils_1.raf)(this.animate);
                }
                else {
                    this.isAnimating = false;
                    this.isScrolling = false;
                    this.animationFrame = null;
                    this.rafId = null;
                }
            };
            this.options = {
                duration: 1000,
                easing: types_1.Easing.easeOutCubic,
                horizontalSensitivity: 1,
                verticalSensitivity: 1,
                disabled: false,
                useNativeScrollOnMobile: true,
                scrollableSelector: "body",
                debug: false,
                ...options,
            };
            this.isMobileDevice = (0, utils_1.isMobile)();
            this.passive = (0, utils_1.supportsPassive)() ? { passive: false } : false;
            this.lastScrollTop = (0, utils_1.getCurrentScrollTop)();
            this.init();
        }
        /**
         * ÎùºÏù¥Î∏åÎü¨Î¶¨ Ï¥àÍ∏∞Ìôî
         */
        init() {
            if (typeof window === "undefined")
                return;
            // Î™®Î∞îÏùºÏóêÏÑú ÎÑ§Ïù¥Ìã∞Î∏å Ïä§ÌÅ¨Î°§ ÏÇ¨Ïö© Ïãú Ï¥àÍ∏∞ÌôîÌïòÏßÄ ÏïäÏùå
            if (this.isMobileDevice && this.options.useNativeScrollOnMobile) {
                this.log("Î™®Î∞îÏùº ÎÑ§Ïù¥Ìã∞Î∏å Ïä§ÌÅ¨Î°§ Î™®Îìú");
                return;
            }
            this.bindEvents();
            this.log("TwoDimensionScroll Ï¥àÍ∏∞Ìôî ÏôÑÎ£å");
        }
        /**
         * Ïù¥Î≤§Ìä∏ Î∞îÏù∏Îî©
         */
        bindEvents() {
            // Ìú† Ïù¥Î≤§Ìä∏ (Îç∞Ïä§ÌÅ¨ÌÜ±)
            document.addEventListener("wheel", this.onWheel, this.passive);
            // ÌÑ∞Ïπò Ïù¥Î≤§Ìä∏ (Î™®Î∞îÏùº/ÌÉúÎ∏îÎ¶ø)
            if ((0, utils_1.isTouchDevice)()) {
                document.addEventListener("touchstart", this.onTouchStart, this.passive);
                document.addEventListener("touchmove", this.onTouchMove, this.passive);
                document.addEventListener("touchend", this.onTouchEnd, this.passive);
            }
            // ÌÇ§Î≥¥Îìú Ïù¥Î≤§Ìä∏
            document.addEventListener("keydown", this.onKeyDown);
            // Î¶¨ÏÇ¨Ïù¥Ï¶à Ïù¥Î≤§Ìä∏
            window.addEventListener("resize", (0, utils_1.throttle)(this.onResize, 100));
        }
        /**
         * Í∞ÄÎ°úÏôÄ ÏÑ∏Î°ú Îç∏ÌÉÄÎ•º Ï°∞Ìï©ÌïòÏó¨ ÏµúÏ¢Ö Îç∏ÌÉÄ Í≥ÑÏÇ∞
         */
        calculateCombinedDelta(deltaX, deltaY) {
            // Í∞ÄÎ°ú Ïä§ÌÅ¨Î°§Ïù¥ Îçî ÌÅ∞ Í≤ΩÏö∞, Í∞ÄÎ°ú Ïä§ÌÅ¨Î°§ÏùÑ ÏÑ∏Î°úÎ°ú Î≥ÄÌôò
            if (Math.abs(deltaX) > Math.abs(deltaY)) {
                return deltaX; // Í∞ÄÎ°ú Ïä§ÌÅ¨Î°§ÏùÑ ÏÑ∏Î°úÎ°ú Î≥ÄÌôò
            }
            // ÏÑ∏Î°ú Ïä§ÌÅ¨Î°§Ïù¥ Îçî ÌÅ¨Í±∞ÎÇò Í∞ôÏùÄ Í≤ΩÏö∞
            if (Math.abs(deltaY) >= Math.abs(deltaX)) {
                return deltaY;
            }
            // Í∞ÄÎ°úÏôÄ ÏÑ∏Î°úÍ∞Ä ÎèôÏãúÏóê Î∞úÏÉùÌïú Í≤ΩÏö∞, Î≤°ÌÑ∞ Ìï© Í≥ÑÏÇ∞
            const magnitude = Math.sqrt(deltaX * deltaX + deltaY * deltaY);
            const angle = Math.atan2(deltaY, deltaX);
            // Í∞ÅÎèÑÏóê Îî∞Îùº Î∞©Ìñ• Í≤∞Ï†ï (-45ÎèÑ ~ 45ÎèÑÎäî Í∞ÄÎ°ú, ÎÇòÎ®∏ÏßÄÎäî ÏÑ∏Î°ú)
            if (Math.abs(angle) < Math.PI / 4 || Math.abs(angle) > (3 * Math.PI) / 4) {
                return deltaX > 0 ? magnitude : -magnitude; // Í∞ÄÎ°ú Î∞©Ìñ•
            }
            else {
                return deltaY > 0 ? magnitude : -magnitude; // ÏÑ∏Î°ú Î∞©Ìñ•
            }
        }
        /**
         * Ïä§ÌÅ¨Î°§ Ï≤òÎ¶¨
         */
        handleScroll(delta, type) {
            if (Math.abs(delta) < 1)
                return;
            const currentScrollTop = (0, utils_1.getCurrentScrollTop)();
            const maxScrollTop = (0, utils_1.getMaxScrollTop)();
            const targetScrollTop = (0, utils_1.clamp)(currentScrollTop + delta, 0, maxScrollTop);
            // Ïä§ÌÅ¨Î°§Ìï† ÌïÑÏöîÍ∞Ä ÏóÜÏúºÎ©¥ Î¶¨ÌÑ¥
            if (Math.abs(targetScrollTop - currentScrollTop) < 1)
                return;
            const direction = delta > 0 ? 1 : -1;
            const eventData = {
                deltaX: 0,
                deltaY: delta,
                scrollTop: currentScrollTop,
                direction,
                type,
            };
            // ÏΩúÎ∞± Ïã§Ìñâ
            this.scrollCallbacks.forEach((callback) => callback(eventData));
            // Î∂ÄÎìúÎü¨Ïö¥ Ïä§ÌÅ¨Î°§ Ïã§Ìñâ
            this.smoothScrollTo(targetScrollTop);
        }
        /**
         * Î∂ÄÎìúÎü¨Ïö¥ Ïä§ÌÅ¨Î°§ Ïã§Ìñâ
         */
        smoothScrollTo(targetPosition) {
            if (this.isAnimating) {
                (0, utils_1.cancelRaf)(this.rafId);
            }
            const startPosition = (0, utils_1.getCurrentScrollTop)();
            const distance = targetPosition - startPosition;
            if (Math.abs(distance) < 1)
                return;
            this.animationFrame = {
                startTime: performance.now(),
                startPosition,
                targetPosition,
                duration: this.options.duration,
                easing: this.options.easing,
            };
            this.isAnimating = true;
            this.isScrolling = true;
            this.animate();
        }
        /**
         * ÌäπÏ†ï ÏúÑÏπòÎ°ú Ïä§ÌÅ¨Î°§
         */
        scrollTo(position, duration) {
            const maxScrollTop = (0, utils_1.getMaxScrollTop)();
            const targetPosition = (0, utils_1.clamp)(position, 0, maxScrollTop);
            if (duration !== undefined) {
                const originalDuration = this.options.duration;
                this.options.duration = duration;
                this.smoothScrollTo(targetPosition);
                this.options.duration = originalDuration;
            }
            else {
                this.smoothScrollTo(targetPosition);
            }
        }
        /**
         * Ïä§ÌÅ¨Î°§ ÏΩúÎ∞± Ï∂îÍ∞Ä
         */
        on(callback) {
            this.scrollCallbacks.add(callback);
        }
        /**
         * Ïä§ÌÅ¨Î°§ ÏΩúÎ∞± Ï†úÍ±∞
         */
        off(callback) {
            this.scrollCallbacks.delete(callback);
        }
        /**
         * Ïä§ÌÅ¨Î°§ ÎπÑÌôúÏÑ±Ìôî
         */
        disable() {
            this.options.disabled = true;
            this.log("Ïä§ÌÅ¨Î°§ ÎπÑÌôúÏÑ±Ìôî");
        }
        /**
         * Ïä§ÌÅ¨Î°§ ÌôúÏÑ±Ìôî
         */
        enable() {
            this.options.disabled = false;
            this.log("Ïä§ÌÅ¨Î°§ ÌôúÏÑ±Ìôî");
        }
        /**
         * ÏòµÏÖò ÏóÖÎç∞Ïù¥Ìä∏
         */
        updateOptions(newOptions) {
            this.options = { ...this.options, ...newOptions };
            this.log("ÏòµÏÖò ÏóÖÎç∞Ïù¥Ìä∏", newOptions);
        }
        /**
         * ÌòÑÏû¨ Ïä§ÌÅ¨Î°§ ÏúÑÏπò Í∞ÄÏ†∏Ïò§Í∏∞
         */
        getCurrentPosition() {
            return (0, utils_1.getCurrentScrollTop)();
        }
        /**
         * ÏµúÎåÄ Ïä§ÌÅ¨Î°§ ÏúÑÏπò Í∞ÄÏ†∏Ïò§Í∏∞
         */
        getMaxPosition() {
            return (0, utils_1.getMaxScrollTop)();
        }
        /**
         * ÎùºÏù¥Î∏åÎü¨Î¶¨ Ìï¥Ï†ú
         */
        destroy() {
            // Ïï†ÎãàÎ©îÏù¥ÏÖò Ï§ëÎã®
            if (this.isAnimating && this.rafId) {
                (0, utils_1.cancelRaf)(this.rafId);
            }
            // Ïù¥Î≤§Ìä∏ Î¶¨Ïä§ÎÑà Ï†úÍ±∞
            document.removeEventListener("wheel", this.onWheel);
            document.removeEventListener("touchstart", this.onTouchStart);
            document.removeEventListener("touchmove", this.onTouchMove);
            document.removeEventListener("touchend", this.onTouchEnd);
            document.removeEventListener("keydown", this.onKeyDown);
            window.removeEventListener("resize", this.onResize);
            // ÏÉÅÌÉú Ï¥àÍ∏∞Ìôî
            this.isAnimating = false;
            this.isScrolling = false;
            this.animationFrame = null;
            this.rafId = null;
            this.scrollCallbacks.clear();
            this.log("TwoDimensionScroll Ìï¥Ï†ú");
        }
        /**
         * ÎîîÎ≤ÑÍ∑∏ Î°úÍ∑∏
         */
        log(...args) {
            if (this.options.debug) {
                console.log("[TwoDimensionScroll]", ...args);
            }
        }
    }
    exports.TwoDimensionScroll = TwoDimensionScroll;
    // Í∏∞Î≥∏ ÎÇ¥Î≥¥ÎÇ¥Í∏∞
    exports.default = TwoDimensionScroll;
    // ÌÉÄÏûÖÍ≥º Ïú†Ìã∏Î¶¨Ìã∞ÎèÑ Ìï®Íªò ÎÇ¥Î≥¥ÎÇ¥Í∏∞
    __exportStar(require("./types"), exports);
    __exportStar(require("./utils"), exports);
    // Î∏åÎùºÏö∞Ï†Ä Ï†ÑÏó≠ Î≥ÄÏàòÎ°ú ÏÑ§Ï†ï (CDN ÏÇ¨Ïö© Ïãú)
    if (typeof window !== "undefined") {
        window.TwoDimensionScroll = TwoDimensionScroll;
    }
});
//# sourceMappingURL=index.js.map